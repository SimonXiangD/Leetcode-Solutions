# 332. Reconstruct Itinerary  
- Method 1

    The classic eulerian problem. Use Hierholzer algorithm.

    One great example is : // exmaple: [["JFK","SFO"],["JFK","ATL"],["SFO","JFK"],["JFK","AAA"],["AAA","JFK"]]

    The reason preorder does not work is, when ending without loop to the beginning, preorder may put it along other loops. However for postorder, such 'bad' road will always be in the end as it has no further loop. Any path with further loop will happen before it.

    | |   Complexity  |
    | ----------- | ----------- | 
    |  Memory     | O(V + E) | 
    |      Time       |  O(ElogE) | 


    Solution:

    ``` h

    class Solution {
    public:
        struct cmp {
            bool operator() (string& a, string& b) {
                return a > b;
            }
        };
        unordered_map<string, priority_queue<string, vector<string>, cmp>> umap;
        void dfs(vector<string>& ans, string cur) {
            while(umap.count(cur) && umap[cur].size()) {
                auto s = umap[cur].top();
                umap[cur].pop();
                dfs(ans, s);
            }
            ans.push_back(cur);
        }
        vector<string> findItinerary(vector<vector<string>>& tickets) {
            vector<string> ans;
            for(auto t : tickets) {
                umap[t[0]].push(t[1]);
            }
            dfs(ans, "JFK");
            reverse(ans.begin(), ans.end());
            return ans;
        }
    };

    ```
<!-- 
- Method 2

    This is another method.

    | |   Complexity  |
    | ----------- | ----------- | 
    |  Memory     | O(n) | 
    |      Time       |  O(n) | 


    Solution:

    ``` h



    ``` -->

- Additional Knowledge:
       
    Whether a graph is eulerian depends on the number of vertex with odd degree.

    You can check [this passage](https://en.oi-wiki.org/graph/euler/) to learn more about euler graph and corresponding algorithms.


    Also there is one detail for this problem, that there can be duplicate edges. With such condition, we cannot use visited bool map to detect, as it may omit some edges:

   ``` h

    class Solution {
    public:
        vector<string> ans;
        unordered_map<string, vector<string>> umap;
        unordered_map<string, unordered_map<string,bool>> vis;
        void dfs(string cur) {
            for(auto str : umap[cur]) {
                if(!vis[cur][str]) {
                    vis[cur][str] = true;
                    dfs(str);
                }
            }
            ans.push_back(cur);
        }
        vector<string> findItinerary(vector<vector<string>>& tickets) {
            for(auto& ticket : tickets) {
                auto t1 = ticket[0], t2 = ticket[1];
                umap[t1].push_back(t2);
            }
            for(auto& [key,val] : umap) sort(val.begin(), val.end());
            dfs("JFK");
            reverse(ans.begin(), ans.end());
            return ans;
        }
    };

    ```



<br>
